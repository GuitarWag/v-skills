import { writeFile, rm, mkdir, readFile } from 'node:fs/promises';
import { join } from 'node:path';
import type { GenerateOptions, GenerateResult, SkillFile, PackageInfo } from './types.js';
import { detectWorkspace, getNodeModulesPaths } from './workspace.js';
import { traverseNodeModules, getDirectDependencies } from './traverse.js';
import { createSkillFile } from './linker.js';
import { fileExists } from './utils.js';

const DEFAULT_OUTPUT = '.claude/skills/v-skills';

/**
 * Ensure the output directory is in .gitignore
 */
async function ensureGitignore(cwd: string, outputDir: string): Promise<void> {
  const gitignorePath = join(cwd, '.gitignore');
  const relativePath = outputDir.startsWith(cwd) ? outputDir.slice(cwd.length + 1) : outputDir;
  const ignoreEntry = `${relativePath}/`;

  try {
    let content = '';
    if (await fileExists(gitignorePath)) {
      content = await readFile(gitignorePath, 'utf-8');
    }

    // Check if already in gitignore
    const lines = content.split('\n');
    const hasEntry = lines.some(line => {
      const trimmed = line.trim();
      return trimmed === ignoreEntry || trimmed === relativePath;
    });

    if (!hasEntry) {
      // Add entry to gitignore
      const newContent =
        content.trimEnd() + '\n\n# v-skills auto-generated documentation\n' + ignoreEntry + '\n';
      await writeFile(gitignorePath, newContent, 'utf-8');
    }
  } catch {
    // Can't update gitignore, silently continue
  }
}

export async function generate(options: GenerateOptions = {}): Promise<GenerateResult> {
  const startTime = Date.now();
  const cwd = options.cwd || process.cwd();
  const outputDir = options.output || join(cwd, DEFAULT_OUTPUT);

  // Clean output directory to remove stale files
  await rm(outputDir, { recursive: true, force: true });

  // Ensure output directory exists
  await mkdir(outputDir, { recursive: true });

  // Ensure gitignore entry
  await ensureGitignore(cwd, outputDir);

  // Detect workspace configuration
  const workspace = await detectWorkspace(cwd);

  // Get direct dependencies if filtering
  let directDeps: Set<string> | null = null;
  if (options.directOnly) {
    directDeps = await getDirectDependencies(cwd);
  }

  // Get all node_modules paths (root + workspace packages)
  const nodeModulesPaths = await getNodeModulesPaths(workspace);

  // Track processed packages to avoid duplicates
  const processed = new Map<string, PackageInfo>();
  let packagesScanned = 0;

  // Traverse all node_modules
  for (const nmPath of nodeModulesPaths) {
    for await (const pkg of traverseNodeModules(nmPath, options)) {
      packagesScanned++;

      // Skip if not a direct dependency (when filtering)
      if (directDeps && !directDeps.has(pkg.name)) {
        continue;
      }

      // Keep the first occurrence (usually from root node_modules)
      const key = pkg.name;
      if (!processed.has(key)) {
        processed.set(key, pkg);
      }
    }
  }

  // Create skill files with folder structure
  const skills: SkillFile[] = [];

  for (const pkg of processed.values()) {
    const skill = await createSkillFile(pkg, outputDir, { useFolderStructure: true });
    if (skill) {
      skills.push(skill);
    }
  }

  // Generate index file
  await generateIndex(outputDir, skills, workspace.type, processed);

  // Generate CLAUDE.md with instructions
  await generateClaudeMd(outputDir);

  return {
    skills,
    workspaceType: workspace.type,
    packagesScanned,
    duration: Date.now() - startTime,
  };
}

async function generateIndex(
  outputDir: string,
  skills: SkillFile[],
  workspaceType: string,
  packages?: Map<string, PackageInfo>
): Promise<void> {
  await mkdir(outputDir, { recursive: true });
  const sorted = [...skills].sort((a, b) => a.name.localeCompare(b.name));
  const now = new Date().toISOString().split('T')[0];

  // Group by scope for better organization
  const scoped: Record<string, SkillFile[]> = {};
  const unscoped: SkillFile[] = [];

  for (const skill of sorted) {
    if (skill.name.startsWith('@')) {
      const scope = skill.name.split('/')[0];
      if (!scoped[scope]) {
        scoped[scope] = [];
      }
      scoped[scope].push(skill);
    } else {
      unscoped.push(skill);
    }
  }

  const lines: string[] = [
    '<!-- v-skills index - auto-generated -->',
    '# Dependency Skills Index',
    '',
    `> Generated by v-skills | Workspace: ${workspaceType} | ${skills.length} packages`,
    '',
    '## Quick Stats',
    '',
    `- **Total Packages:** ${skills.length}`,
    `- **Scoped Packages:** ${sorted.length - unscoped.length}`,
    `- **Workspace Type:** ${workspaceType}`,
    `- **Last Updated:** ${now}`,
    '',
  ];

  // Helper to get package metadata
  const getPackageInfo = (name: string) => packages?.get(name);
  const formatKeywords = (keywords?: string[]) => {
    if (!keywords || !Array.isArray(keywords) || keywords.length === 0) {
      return '-';
    }
    return keywords.slice(0, 5).join(', ');
  };
  const truncate = (text: string, maxLen: number) =>
    text.length > maxLen ? text.slice(0, maxLen - 3) + '...' : text;

  // Unscoped packages
  if (unscoped.length > 0) {
    lines.push('## Packages');
    lines.push('');
    lines.push('| Package | Version | Description | Keywords |');
    lines.push('|---------|---------|-------------|----------|');

    for (const skill of unscoped) {
      const pkg = getPackageInfo(skill.name);
      const desc = pkg?.description ? truncate(pkg.description, 60) : '-';
      const keywords = formatKeywords(pkg?.keywords);
      lines.push(
        `| [${skill.name}](./${skill.name}/SKILL.md) | ${skill.version} | ${desc} | ${keywords} |`
      );
    }
    lines.push('');
  }

  // Scoped packages by scope
  const scopeNames = Object.keys(scoped).sort();
  if (scopeNames.length > 0) {
    lines.push('## Scoped Packages');
    lines.push('');

    for (const scope of scopeNames) {
      const scopeSkills = scoped[scope];
      lines.push(`### ${scope}`);
      lines.push('');
      lines.push('| Package | Version | Description | Keywords |');
      lines.push('|---------|---------|-------------|----------|');

      for (const skill of scopeSkills) {
        const shortName = skill.name.replace(`${scope}/`, '');
        const pkg = getPackageInfo(skill.name);
        const desc = pkg?.description ? truncate(pkg.description, 60) : '-';
        const keywords = formatKeywords(pkg?.keywords);
        lines.push(
          `| [${shortName}](./${skill.name}/SKILL.md) | ${skill.version} | ${desc} | ${keywords} |`
        );
      }
      lines.push('');
    }
  }

  lines.push(
    '## About',
    '',
    'Each package folder contains a `SKILL.md` file with:',
    '- Package metadata (version, homepage, repository, license)',
    '- Full README documentation',
    '- Links to TypeScript definitions',
    '- Links to docs/ folder (if available)',
    '- Recent changelog entries',
    '- Additional documentation (CONTRIBUTING, API, etc.)',
    '',
    '---',
    `*Auto-generated by v-skills on ${now}. Do not edit manually.*`
  );

  await writeFile(join(outputDir, '_index.md'), lines.join('\n'));
}

async function generateClaudeMd(outputDir: string): Promise<void> {
  const content = `# v-skills Documentation

This folder contains auto-generated skill files for installed npm packages.

## For Claude Code AI

**IMPORTANT**: Before searching through individual SKILL.md files, always check \`_index.md\` first.

The index contains:
- Full package list with descriptions and keywords
- Quick stats about installed dependencies
- Organized by scoped/unscoped packages

### Recommended Workflow

1. **Start with the index**: Read \`_index.md\` to get an overview and find relevant packages
2. **Use descriptions/keywords**: Search the index for packages related to your task
3. **Read specific SKILL.md**: Once you identify relevant packages, read their full documentation

This approach is much more efficient than randomly opening SKILL.md files, especially in projects with 100+ dependencies.

---
*Generated by v-skills*
`;

  await writeFile(join(outputDir, 'CLAUDE.md'), content);
}

export async function clean(options: { cwd?: string; output?: string } = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const outputDir = options.output || join(cwd, DEFAULT_OUTPUT);

  await rm(outputDir, { recursive: true, force: true });
}
